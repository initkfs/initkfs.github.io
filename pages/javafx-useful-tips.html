<!doctype html>
<html lang="ru">
<head>
    <meta charset='utf-8'>
    <meta name="yandex-verification" content="7021eeb9c07b5c09">
    <meta name="google-site-verification" content="PztbVe6Ru8ggM2n_tWUYwy0bEVHtJNvzIr-nsVCvBCA">
    
    
    <meta content='width=device-width, initial-scale=1' name='viewport'>
    <!-- favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="/assets/stab/img/favicons/favicon.ico">
    <link rel="icon" type="image/png" href="/assets/stab/img/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/assets/stab/img/favicons/favicon-16x16.png" sizes="16x16">
    <link rel="mask-icon" href="/assets/stab/img/favicons/safari-pinned-tab.svg" color="#004245">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/stab/img/favicons/apple-touch-icon.png">
    <meta name="msapplication-config" content="/assets/stab/img/favicons/browserconfig.xml">
    <!-- end favicons -->
    <!-- rss feeds -->
    <link rel=alternate title="RSS лента" type=application/rss+xml href='/rss-all.xml'>
    <!-- end rss feeds -->
    <link type="text/plain" rel="author" href="/humans.txt">
    <link crossorigin='anonymous' href='https://cdn.materialdesignicons.com/3.5.95/css/materialdesignicons.min.css'
          integrity='sha384-Ls5zBitvvQ/wdeZDuTUevSY5Tb/she50BeMPrco2ok6xDC8modj6/JPwdL0gNxmP' rel='stylesheet'>
    
    <link crossorigin='anonymous' integrity='sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ=='
          href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    
    <link href="/assets/dev/css/main.css" rel='stylesheet'>
    
    <title>JavaFX - полезные советы, ссылки, ресурсы. Космическая станция Аналитики - DIY техноблог о сложных IT-проектах</title>
    <meta name="description" content="Полезные ресурсы и советы о JavaFX (OpenJFX)">
    <meta content='JavaFX - полезные советы, ссылки, ресурсы. Космическая станция Аналитики - DIY техноблог о сложных IT-проектах' property='og:title'>
    
    <meta name="keywords" content="javafx,openjfx,ссылки,советы,ресурсы">
    
    <meta content='/index.html' property='og:url'>
    <meta content='website' property='og:type'>
    <meta content='ru_RU' property='og:locale'>
</head>
<body>
<div class='container mb-3'>
    <div class='row'>
        <div class='col-lg-12'>
           <div class='card w-100 site-header-container'>
    <div class='row align-items-center'>
        <div class="col-lg-9">
            <div class='card-header site-header'>
                <div class='card-title site-header-title mb-3'>
                    <h5 class='site-header-title-text'>
                        <a href='/index.html' class='blog-title-text-link'>Космическая станция Аналитики - DIY техноблог о сложных IT-проектах</
                    </h5>
                </div>
                <div class='card-subtitle site-header-subtitle mb-2'>
                     <a href="/pages/about.html" class="badge mb-2 mb-sm-0">О станции и капитане</a>  <a href="/pages/site-implementation.html" class="badge">Сайт (Groovy-генератор)</a> 
                </div>
            </div>
        </div>
        <div class="col-lg-3">
            
            <div class='site-map w-100 d-flex justify-content-center pe-lg-3'>
                <a class='site-map-link btn w-100' href='/site-map.html' role='button'><span
                        class='site-map-link-icon mdi mdi-sitemap'></span>
                    <span class='text-clarification'>Карта сайта (все статьи)</span></a>
            </div>
            
        </div>
    </div>
</div>
        </div>
    </div>
</div>
<div class='container'>
    <div class='row'>
        <div class='col-lg-9 blog-posts'>
            <article class='card post'>
    <h5 class='card-header post-header fw-bold'>
        JavaFX - полезные советы, ссылки, ресурсы
    </h5>
    <div class='card-body post-body'>
        <div class="card-title mb-3">
            <div class="post-body-header">

<div class='post-header-date'><span class='mdi mdi-calendar-clock'></span>
    <span class="post-datetime-text" data-iso-time="2019-12-29">29 декабря 2019</span>
</div>



<div class='post-labels'>
    <span class='post-header-labels-icon mdi mdi-tag-outline'></span>
    
    <a class='post-label-item badge font-weight-normal'
       href='/tags/javafx.html' rel='tag'>JavaFX
    </a>
    
</div>
</div>
        </div>
        <div class='post-content'><p>Несмотря на наличие <a href="https://github.com/mhrimaz/AwesomeJavaFX">AwesomeJavaFX</a>, я всё же решил оформить статью с небольшой коллекцией заметок. Подобного дополнения к набору ссылок и туториалов мне когда-то очень сильно не хватало, из-за чего было потрачено очень большое количество времени моей жизни.</p>
<ol>
<li><a href="#javafx_rus_resources">Русскоязычные ресурсы</a></li>
<li><a href="#javafx_common_resources">Архитектура тулкита и api</a></li>
<li><a href="#javafx_tools_resources">Инструменты разработки</a></li>
<li><a href="#javafx_other_resources">Разные полезные ресурсы</a></li>
<li><a href="#javafx_other_tips">Заметки о JavaFX-приложении</a></li>
</ol>
<p>Предполагаю, что вы знакомы с общим описанием тулкита и его устройством: <a href="https://docs.oracle.com/javafx/2/architecture/jfxpub-architecture.htm">JavaFX Architecture</a> или в рамках туториалов\книг в разделах <a href="https://github.com/mhrimaz/AwesomeJavaFX">AwesomeJavaFX</a>, который я не буду стараться дублировать или википедии и т.п. обзорным материалам. В дополнение к англоязычным урокам вспомним русскоязычные.</p>
<h4><a name="javafx_rus_resources"></a>Русскоязычные ресурсы</h4>
<ul>
<li><a href="https://habr.com/ru/post/474292/">Учебник по JavaFX: начало работы</a></li>
<li><a href="https://habr.com/ru/post/339382/">Скажи «нет» Electron! Пишем быстрое десктопное приложение на JavaFX</a> и другие статьи на хабре, которых достаточно много и легко найти через поиск.</li>
<li><a href="https://metanit.com/java/javafx/">https://metanit.com/java/javafx/</a></li>
<li><a href="https://o7planning.org/ru/11009/javafx">https://o7planning.org/ru/11009/javafx</a></li>
<li><a href="https://code.makery.ch/ru/library/javafx-tutorial">https://code.makery.ch/ru/library/javafx-tutorial</a></li>
</ul>
<p>Русскоязычной литературы мало:</p>
<ul>
<li>Тимур Машнин. JavaFX 2.0 Разработка RIA-приложений. 2012 года, хотя бы она и слегка устарела, но можно использовать для знакомства с основами. Однако есть отличия: билдеры уже устарели и deprecated, в 9 много новых полезных нововведений, навроде <a href="https://bugs.openjdk.java.net/browse/JDK-8091132">Support JavaFX MediaPlayer over HTTPS</a>, <a href="https://bugs.openjdk.java.net/browse/JDK-8098046">Add support for @import in CSS</a>, <a href="https://bugs.openjdk.java.net/browse/JDK-8090585">Provide an official API to start the JavaFX platform</a>, <a href="https://bugs.openjdk.java.net/browse/JDK-8144628">Provide API to expose list of showing Windows</a> и т.п., что нужно учитывать.</li>
<li>Прохоренок Н.А. JavaFX. 2019 года.</li>
</ul>
<p>Список англоязычной литературы есть на гитхабе.</p>
<h4><a name="javafx_common_resources"></a>Архитектура тулкита и api</h4>
<p>C Java 11 JavaFX отделен от JDK, есть собственный сайт <a href="https://openjfx.io">https://openjfx.io</a></p>
<p>Скорее всего вам будут постоянно попадаться туториалы прошлых лет, то отмечу несколько важных докладов, которые помогут адаптировать легаси-код:<br/>Доклад от Kevin Rushforth и Jonathan Giles (2016): JavaFX: New &amp; Noteworthy<br/><a href="https://static.rainfocus.com/oracle/oow16/sess/1462485593256001c2xn/ppt/JavaFX%209%20-%20New%20and%20Noteworthy.pdf">https://static.rainfocus.com/oracle/oow16/sess/1462485593256001c2xn/ppt/JavaFX%209%20-%20New%20and%20Noteworthy.pdf</a> о чрезвычайно важных нововведениях в 9 версии.</p>
<p>Building JavaFX UI Controls<br/><a href="https://static.rainfocus.com/oracle/oow16/sess/1462484351438001p6a1/ppt/Custom%20Controls.pdf">https://static.rainfocus.com/oracle/oow16/sess/1462484351438001p6a1/ppt/Custom%20Controls.pdf</a> об устройстве контролов и кастомизации.</p>
<p>Особенно полезен проект с альтернативной документацией, много нюансов: <a href="https://fxdocs.github.io/docs/index.html">JavaFX Documentation Project</a></p>
<p>Существует вики: <a href="https://wiki.openjdk.java.net/display/OpenJFX">https://wiki.openjdk.java.net/display/OpenJFX</a>, где можно найти также и ссылки на css, fxml документацию. Разве что некоторые устаревшие ссылки запрятаны достаточно глубоко, хотя все еще могут быть чем-то полезны, например, эта статья о производительности: <a href="https://wiki.openjdk.java.net/display/OpenJFX/Performance+Tips+and+Tricks">https://wiki.openjdk.java.net/display/OpenJFX/Performance+Tips+and+Tricks</a></p>
<p>Репозитории тулкита:<br/><a href="https://github.com/openjdk/jfx">https://github.com/openjdk/jfx</a><br/><a href="http://hg.openjdk.java.net/openjfx">http://hg.openjdk.java.net/openjfx</a></p>
<p><a href="https://bugs.openjdk.java.net/issues/?jql=project%20%3D%20JDK%20AND%20component%20%3D%20javafx">Багтрекер</a>, на котором вы скорее всего будете очень частым гостем.</p>
<p>Рассылка для разработчиков: <a href="http://mail.openjdk.java.net/pipermail/openjfx-dev/">http://mail.openjdk.java.net/pipermail/openjfx-dev/</a></p>
<p>Dirk Lemmermann поддерживает один из ключевых сайтов инфраструктуры <a href="https://www.jfx-central.com">JFX-Central</a>.</p>
<h4><a name="javafx_tools_resources"></a>Инструменты разработки</h4>
<p>Некоторые ссылки переместились с сайтов Oracle на сайт Gluon. Закономерно опасение разработчика что-то скачивать с другого сайта, но это действительно так: <a href="https://dzone.com/articles/bye-bye-javafx-scene-builder">Bye Bye JavaFX Scene Builder, Welcome Gluon Scene Builder 8.0.0</a></p>
<p>Ключевое приложение JavaFX-инфраструктуры графический FXML-редактор SceneBuilder теперь живет на сайте Gluon: <a href="https://gluonhq.com/products/scene-builder/">https://gluonhq.com/products/scene-builder/</a> Программа имеет несколько противных багов, но вполне работоспособна. Также он встроен в IDE, однако у многих работает проблемно с такой интеграцией.</p>
<p>На этом же сайте можно скачать и либы JavaFX раннего доступа в обход Maven-репозиториев: <a href="https://gluonhq.com/products/javafx/">https://gluonhq.com/products/javafx/</a></p>
<p>Один из очень полезных инструментов Scenic View, программа для просмотра графы сцены с выводом различной информации об узлах: <a href="https://github.com/JonathanGiles/scenic-view">https://github.com/JonathanGiles/scenic-view</a>. С программой раньше были определенные проблемы и после добавления отладочного окна в собственное приложение я практически её не использую. Большая часть задач сводится обычно к перерасчету различных координат узла в родительские координаты, сцены в экран и т.п., что делает просмотр геометрии узлов жизненно необходимым. Также множество проблем может быть со стороны CSS, здесь она тоже поможет.</p>
<h4><a name="javafx_other_resources"></a>Разные полезные ресурсы</h4>
<p>Некоторые блоги стоит вспомнить еще раз, хотя бы они и есть в awesome-списке, например:</p>
<p><a href="http://news.kynosarges.org/tag/javafx">Christoph Nahr</a>, есть очень полезные заметки, о нюансах масштабирования интерфейса и т.п.</p>
<p><a href="https://bekwam.blogspot.com">Carl Walker</a>, много примеров более сложных биндингов, привязка размеров списков, логические операции, биндинг на пустые строки и т.п. С биндингами можно сделать много разных удобных вещей.</p>
<p><a href="http://www.harmonic-code.org">Gerrit Grunwald</a> и его репозитории <a href="https://github.com/HanSolo">github.com/HanSolo</a>, в которых можно найти много полезного, особенно по кастомным контролам, я и сам в них часто копался.</p>
<p><a href="https://dlsc.com/blog">Dirk Lemmermann</a>, также множество полезных идей и реализаций функционала.</p>
<p>Немного статей также есть и на <a href="https://www.javacodegeeks.com/tag/javafx">https://www.javacodegeeks.com/tag/javafx</a></p>
<p>Обзор WebView: <a href="https://blogs.oracle.com/java/javafx-webview-overview">JavaFX WebView Overview</a></p>
<p>Запуск на Raspberry Pi 4: <a href="https://bell-sw.com/announcements/2019/09/12/JDK-JavaFX-Video-Preview/">Liberica JDK 13 EA With OpenJFX 13 On The Raspberry Pi 4</a></p>
<p>Альтернативный билд OpenJDK, содержащий OpenJFX: <a href="https://www.azul.com">Zulu</a></p>
<h4><a name="javafx_other_tips"></a>Заметки о JavaFX-приложении</h4>
<p>Вспомню несколько практических моментов, особенно если вы не используете Spring, другие тяжелые зависимости, хотите поэкспериментировать с архитектурой, получить опыт или просто построить приложение с нуля ради фана.</p>
<p>Тулкит обладает очень большой гибкостью в построении приложения и разные задачи можно решить различными способами. Для самого простого приложения вполне достаточно самой примитивной архитектуры с использованием всех возможностей FXML, которые на самом деле даже шире (переменные, вычисляемые значения и т.п.), чем их поддерживает SceneBuilder. Это позволяет быстро создать прототип, однако переход его на более высокие уровни организации требует уже продумывания минимальной архитектуры.</p>
<p>Если вы создаете приложение с нуля, то оно склонно постепенно разрастаться и расслаиваться, требуя выделения ядра фреймворка, общей логики для приложений этого класса (в нашем случае десктопных) и специфической предметной логики, которая решает специфические задачи каждого конкретного приложения. Если этого не сделать, то реиспользование кода в будущем станет проблематичным, хотя архитектура в целом упростится. С другой стороны, на уровне прототипа такое разделение часто может быть избыточным и ничем хорошим не закончится, поскольку неизвестно, выживет ли написанный код или нет, а в IDE из мира Java очень хороший рефакторинг.</p>
<p>Как правило, любое десктопное приложение начинает сочетать в себе признаки фронтенда и бэкенда. Если задача более-менее серьезная, то на самом раннем этапе есть смысл продумать управление зависимостями, поскольку это определит большую часть архитектуры. Это важно для сквозной логики и стыков слоев приложения (например, контроллер-модель), любые переделки в этих местах потребуют поломки всего приложения. В менее критичных участках излишнее усердие по пробросу зависимостей может даже навредить, сильно всё запутывая.</p>
<p>Для простого приложения IoC-контейнер может оказаться излишним. Напомню, что есть книга на эту тему: Марк Симан, Внедрение зависимостей в .NET, принципы которой вполне универсальны и относятся не только к C#, хотя некоторые моменты достаточно спорны. Здесь есть шанс все усложнить и запутать, получив на выходе более худший результат, чем без управления зависимостями вообще, любое усложнение требует осторожности.</p>
<p>Наряду с разными <a href="https://dev.to/_maimart_/architecture-of-a-javafx-application-2geb">подходами</a>, в самом простом случае можно выбрать иерархичную архитектуру &quot;служб&quot; (я взял слово в кавычки, ибо каждый автор понимает его по-разному): в главном классе или билдере собрать все зависимости, например, логгер, конфиг и т.п., передать контроллеру, который передает их всем остальным - вложенным контроллерам, моделям и т.п.</p>
<p>Однако этот простой способ, кроме инициализации сразу большого графа объектов имеет и еще один очень существенный недостаток: появляется вопрос об уровнях вложенности служб друг в друга, поскольку количество их всегда будет расти, требуя наличия агрегатов.</p>
<p>Это одна из отложенных архитектурных проблем, например, вы имеете менеджер языковых ресурсов и определяете его на поле в каком-либо рутовом компоненте вашего приложения, передавая его остальным. Далее появится менеджер локали, времени и т.п., что входит в интернационализацию. Так будет постепенно расслаиваться каждая &quot;служба&quot;, которая была когда-то одним классом, но т.к. управлять и уследить за огромным числом зависимостей невозможно, то большое их количество требует агрегата, который не делает ничего, лишь организуя следующий уровень вложенности: getLocaleManager() превращается в getI18n().getLocaleManager() или в сложных случаях спасает положение, организовывая между ними какое-то взаимодействие. Поэтому часто встречается подход - делать подобные агрегаты сразу, не ломая в будущем код.</p>
<p>Несложно догадаться, что с ростом уровней вложенности растут и проблемы использования api и читаемости кода. У приложения появляется потолок, при достижении которого нужно будет объединять ответственность классов, что приведет к другим проблемам. Еще одной проблемой может быть сама передача зависимостей другим компонентам. Какой бы способ не был использован, но все равно корректнее вызывать сеттеры у собираемого компонента, что, конечно же, можно сделать рефлексией. Если по каким-то причинам рефлексия невозможна, то это также ограничивает количество зависимостей, иначе каждый раз нужно будет править эти билдеры\фабрики.</p>
<p>Несмотря на множественные недостатки, такая структура может неплохо сработать для небольшого приложения и в этом случае имеет больше преимуществ, нежели сложный в сопровождении и отладке контейнер зависимостей, который имеет уже свои собственные проблемы и ограничения, да и легковесных альтернатив в Java-мире не особо много. Она хороша и тем, что вписывается в логику работы мышления - при поиске апи сначала отнести его к какой-то области, например, графике, затем к частности, например, менеджер иконок и т.п. что удобно при подсветке методов в IDE. Она проста и интуитивна, легко отлаживается, гибка, кроме того, способна предотвращать некоторые архитектурные ошибки.</p>
<p>Поскольку множественного наследования нет, то скорее всего основные компоненты фреймворка будут наследоваться от других и слою предметной логики будет проблематично настраивать их. Здесь возможен хак: пропустить иерархию наследования через предметную логику, завязав на ней ядро фреймворка. Это самый простой способ усложнит отделение библиотек (разве что может выручить  Service Provider Interface, он же SPI), но решит часть проблем. Другой вариант, часто порицаемый <a href="https://ru.wikipedia.org/wiki/Локатор_служб">Service Locator</a> и его варианты, что уже недалеко и от DI-контейнеров. Тогда при невозможности наследования можно пробросить зависимость через него.</p>
<p>Какое бы решение вы не выбрали - использовать IoC-контейнер, простой проброс объектов друг другу или гибридный вариант, сочетающий все сразу, но это решение будет критичным для приложения и сильно отразится на его будущем, определяя иерархию самых базовых классов приложения\фреймворка от которого будут наследоваться остальные компоненты - контроллеры, модели, сервисы и т.п.</p>
<p>В рутовой иерархии можно легко получить <a href="https://ru.wikipedia.org/wiki/Хрупкий_базовый_класс">хрупкий базовый класс</a>, а использования инжекции в конструктор при обязательном переопределении конструкторов в Java может привести к внезапной поломке конструкторов всей иерархии при изменениях. Можно использовать Lombok и подобные проекты в базовых компонентах, но обратной стороной будет завязка сквозной логики на стороннюю библиотеку, проблемы с которой приведут ровно также к масштабной поломке всего приложения.</p>
<p>Здесь можно получить массу проблем и нужно тщательно взвесить преимущества и недостатки выбранного решения. В конце концов, вы можете вообще не заниматься никакими зависимостями, инстанцируя все самые важные службы\сервисы в коде или используя статику, но любые архитектурные решения имеют свои недостатки и нужно все равно подумать о последствиях.</p>
<p>Типичный JavaFX-туториал использует, по крайней мере, один контроллер окна. У более сложного приложения в случае наличия только одного контроллера главного окна могут быть самые различные проблемы, например, при наличии таймера, при работе трея или виджета кто-то должен управлять сообщениями между ними и главным окном, особенно если какое-то окно скрыто. Если контроллер главного окна будет управлять еще и треем, то это усложняет его использование как простого FXML-контроллера. А если скрыты все окна и приложение имеет настройку не загружать окна вообще, то это еще проблемнее.</p>
<p>Одним из самых простых вариантов может быть выделение главного контроллера приложения, который управляет всем остальным, но не содержит в себе контролов или чего-то связанного с интерфейсом. Обратной стороной такого решения будет, конечно же, усложнение обмена событиями между контроллерами. Это первые намеки на то, что логика управления окнами и FXML-контроллерами будет особенно неприятным местом, поэтому неплохо бы определиться с окнами и FXML.</p>
<p>Я наблюдал различные подходы к FXML: кто-то активно использует создание контролов только в коде, кто-то лишь в случаях небольших открываемых окон\диалогов, а в остальной части шаблоны. У каждого решения есть свои преимущества и недостатки для разных ситуаций. Полагаю, что для большинства (в т.ч. и для меня) сильной стороной тулкита является скорость прототипирования и необходимость постоянного редактирования интерфейса, что требует FXML в связке со SceneBuilder для основных окон и создание из кода для простого функционала, где загрузка fxml-шаблона неоправданна.</p>
<p>Очень удобным решением в этом случае будет и <a href="https://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html#nested_controllers">композиция контроллеров</a>, с помощью которой можно привязывать отдельный контроллер к табу в TabPane, разгружать особо толстенькие контроллеры и т.п. Это очень удобно, однако сильно влияет на архитектуру. Вам нужно инициализировать или управлять этими контроллерами: через фабрику в FXMLLoader, либо вручную.</p>
<p>В случае FXML есть смысл сразу определить границы его влияния на приложение: слушатели можно установить как в FXML, как и в коде на сам контрол. У каждого метода свои преимущества и недостатки, как всегда. Поэкспериментировав, я убрал все привязки вызовов методов из FXML, переместив их в код, чтобы не разбрасывать логику, однако это не подходит для специфических случаев, например, для возможности изменения вызова метода путем редактирования fxml-шаблона, что намекает на продумывание местоположения FXML - или jar-файл или в какой-нибудь директории.</p>
<p>После перебора разных вариантов деплоя я остановился на разделении кода и ресурсов, все ресурсы (в т.ч. и fxml-файлы) хранятся в директории данных. Такой подход сильно облегчает фикс ошибок и обслуживание приложения, вплоть до быстрого изменения интерфейса и его поведения за счёт правки fxml. С другой стороны, для приложения, требующего безопасности этот вариант выглядит очень опасным. Я не нашел каких-либо материалов о возможных уязвимостях через шаблоны и css, но этого явно стоит опасаться и наверное есть смысл условно признать их уязвимыми, учитывая возможности и тесную интеграцию с кодом.</p>
<p>В FXML можно привязать не только методы, но использовать интернационализацию в виде %ключа, а также пути к изображениям. Если у вас будет какой-нибудь менеджер языковых ресурсов, то нужно как-то передавать их в шаблоны. А вот с изображениями проблемнее, особенно в CSS-теме. Тулкит имеет функцию автомасштабирования <a href="https://dlsc.com/2017/08/29/javafx-tip-27-hires-retina-icons/">JavaFX Tip 27: HiRes / Retina Icons</a> через постфикс @2x в имени файла изображения. Однако если приложение имеет настройку размеров иконок или как-то управляет ими, то пути в FXML могут многое осложнить, хотя они чрезвычайно удобны для быстрой разработки. Поразмыслив так и желая подстраховаться на случай различных проблем и багов тулкита на разных системах, я полностью убрал иконки из FXML, переместив работу с любой графикой в код, но опять таки, это может быть не всегда удобным.</p>
<p>На этом этапе также может потребоваться определить и структуру директорий данных программы, как их хранить и где. Это может отвлечь на реализацию конфигурации, интернационализации, графики и обработки командной строки (у Application есть getParameters, которого может быть достаточным для очень простых случаев).</p>
<p>Конечно же, на этапе прототипа неверно определенное api скорее просто приведет к потери времени, о чем следует помнить и не заморачиваться особо. С другой стороны, любое изменение в последующем будет порождать регрессионные баги, поэтому основные вспомогательные службы\сервисы есть смысл продумывать сразу.</p>
<p>Хорошо себя зарекомендовала валидация конфигов и проверка директорий данных. Пользовательские или любые другие важные данные обычно склонны бэкапиться, что намекает на их отделение.</p>
<p>Если есть задача полностью портабельного приложения, то нужно помнить о директориях, которые неочевидно создает запуск приложения в системе: директория с кешируемыми либами, сохраняемые настройки LocalStorage из WebEngine, для изменения которой есть setUserDataDirectory.</p>
<p>Приложение усложнится и может потребоваться отладка. CLI может очень сильно сэкономить время, например, через переопределение ключей конфига, позволяя создавать различные конфигурации запуска для приложения. С другой стороны, для приложения, требующего безопасности, это может привести ко множественным уязвимостям.</p>
<p>Однако большое количество багов будет не только в логике, но и в интерфейсе. Вы можете использовать либо ту же ScenicView, либо как я, разработать свой вариант отладочного окна, который позволяет быстро просмотреть структуру контрола или изменить его геометрию.</p>
<p>На фоне усложнения логики все больше будут проявляться мелкие недоделки тулкита, имея тенденцию сливаться в большие проблемы. Даже на самом раннем этапе есть смысл сразу выделить хелперы\службу\сервис, которая будет ответственна за фиксы контролов.</p>
<p>После Java 9 появились сильные ограничения в рефлексии, в некоторых случаях может потребоваться расковырять исходники контрола и выносить логику в свои классы. Есть и другой путь - через кастомизацию контролов. Некоторые улучшения, например, контекстные меню или копирование текста Label можно реализовать кастомным контролом, недостаток - необходимость добавления их в SceneBuilder, многочисленность таких кастомных контролов с неудобством каждый раз подменять их в fxml или создавать их кода. При этом в менее важных окнах некоторым функционалом можно и пожертвовать.</p>
<p>Идея такой службы фиксов у меня появилась отсюда: <a href="https://habr.com/ru/post/422693/">Команда плагинов для настройки JavaFX компонент в настольном приложении</a>. Сам концепт универсален и полезен для любого тулкита вообще, не только десктопного. Конечно же, на этапе прототипа такое расслоение проблематично, но в будущем способно сэкономить много времени, как и получить трудноуловимую утечку памяти за счет затерянной жесткой ссылки на слушатель или т.п. и за чем нужно следить. Еще один недостаток - возможность очень сильно запутать и осложнить борьбу с багами за счет дополнительной прослойки кода с фиксами, проблемы в котором перемешиваются с проблемами самого тулкита.</p>
<p>Где-то в районе появления множества контроллеров у вас будет большое количество багов и растущее приложение потребует структурирования и компенсации еще одной особенности ООП - взаимодействие между объектами, расположенных достаточно далеко друг от друга.</p>
<p>Обычным наблюдателем это реализовать проблематично, нужно пробрасывать очень много зависимостей. Я выбрал шину сообщений, как наиболее простой вариант, сначала на Guava: <a href="https://github.com/google/guava/wiki/EventBusExplained">EventBusExplained</a>, а затем заменил на свою реализацию, ибо сложной многопоточности у меня не требуется и за счет наличия Platform.runLater можно сильно упростить передачу сообщений, сделав отладку и контроль за ними более удобными, ну и удалить лишнюю зависимость. Конечно же, шина также имеет множественные недостатки и способна запросто превратить жизнь в событийный ад. Поэтому для относительно простых приложений шина может создать больше вреда, чем пользы, да и последующее удаление шины из приложения очень и очень трудоёмкая задача, что создаёт основной риск.</p>
<p>В конце концов, начнутся проблемы с багами и в различных состояниях приложения. Если вы удачно начали приложения с TabPane и вложенными контроллерами выше, которые нужно запускать и останавливать, а также если кейсом было приложение, где есть смена окон или состояний (игра, тесты и т.п.), то этот вопрос поднимется сразу.</p>
<p>Есть разные варианты, например, из мира C#: <a href="https://habr.com/ru/post/160105/">Простые стейт-машины на службе у разработчика</a>, однако моя велосипедная собственно-реализованная стейт-машина на графах оказалась слишком сложной и неудобной для повседневного использования, хотя бы и помогла поймать у одного из моих пользователей двойной клик поломанной мышки. В некоторых случаях удобнее замаскировать TabPane, удалив хидер и вручную переключая табы, создавая видимость смены окна, это костыльно, но вполне работающий вариант, конечно же, до определенного момента.</p>
<p>Что касается структурирования самих контролов, то я пробовал придумать какие-то правила работы с ними в методах инициализации контроллеров, определяя строгий порядок их настройки, разделяя комментариями и т.п., но все идеи оказались нежизнеспособными или тратили время впустую не давая особых выгод. Пока этот вопрос остается для меня открытым. Как правило, любая библиотека, которая должна что-то одно облегчать - усложняет что-то другое, например, отладку, понимание кода и т.п., что плохо подходит для повсеместного применения.</p>
<p>В разных ситуациях может потребоваться освобождение ресурсов контроллером. Можно объединить управление состояниями контроллеров и события окна, например, при его закрытии останавливая контроллер и освобождая ресурсы, если окно больше не будет использовано. Однако в этом случае рождается тонкий баг для вложенных контроллеров, состояния которых могут переключаться некорректно если они также должны иметь доступ к окну.</p>
<p>Большое количество багов потребует валидации объектов, заняться валидаторами стоит пораньше. В части JavaFX валидация очень полезна для проверки @FXML полей контроллеров на null, что бывает чрезвычайно часто из-за постоянной правки шаблонов. SceneBuilder может сгенерировать такие проверки, однако при частом изменении полей этот метод нужно будет постоянно корректировать, а это жутко неудобно.</p>
<p>Валидатор может многое упростить и сэкономить время на поиск бага. Это была одна из моих первых ошибок при знакомстве с тулкитом. Я решил отложить валидаторы на попозже, начав работать над менеджером самодиагностики приложения. У меня появились правила, например, проверки лога на ошибки, ключей в конфиге и т.п. и менеджер, которые ими управляет. После появления пакета валидаторов оказалось, что логика этих правил диагностики дублирует логику валидаторов и пришлось сильно все менять, конечно же получая регрессионные баги где только можно. Здесь грех не использовать валидацию бинов, я, например, перевел приложение на Jakarta Bean Validation API, однако не желая тянуть в зависимость приложения громоздкие валидаторы, некоторые простые проверки пришлось реализовывать вручную. С другой стороны, апи завязывается на пакет валидаторов, усложняя реиспользование кода.</p>
<p>Можно ли валидировать FXML, учитывая потенциально бесконечные варианты рантаймовых в нем ошибок? В 9 версии появился javafx.fxml.LoadListener, который можно использовать для перехвата парсинга и проверки, например, путей иконок. Однако есть проблема в большом количестве окон и файлов fxml-шаблонов, привязанных к ним, а в каждом из них может быть потенциальная ошибка. В конце концов, не найдя более лучшего способа, я просто добавил в режиме дебага валидатор, который вхолостую прогружает все FXML-файлы, пытаясь перехватить эксепшен и уведомляя о баге. Способ достаточно затратен и может быть проблемным за счет инклюдинга и т.п. фич FXML.</p>
<p>Большое количество разнообразных валидаторов и сложность их иерархии (как и любая подобная логика) может на поздних этапах захотеть многопоточности из-за какого-то особо тугодумного валидатора. Добавление многопоточности в любую развитую или сложную логику может потребовать полного перепроектирования, очень и очень болезненного, так что нужно всегда помнить об этом риске.</p>
<p>Рано или поздно потребуется работа с базой данных. При этом вскроются недостатки Java как интерпрайзного языка и малое количество актуальных легковесных библиотек еще и с учетом того, что в десктопных приложениях очень активно используется SQLite. Конечно же, можно взять любую библиотеку, однако зависимость в приложении автоматически ставит вас в зависимость от этой зависимости и тем больше зависимость, тем больше ваша зависимость, такой вот каламбур.</p>
<p>Например, при переходе на Java 9 у меня <a href="https://github.com/j256/ormlite-jdbc/issues/31">умерла</a> ORMLite. Все же десктопное программирование в мире Java развито очень слабо, в условиях бедности на альтернативы это было достаточно катастрофичным событием и был выбор: пересобирать ORMLite, меняя имена пакетов для исключения конфликта либо удалить её и разработать примитивную замену.</p>
<p>Вместе с логикой доступа к данным потребуется активное взаимодействие с пользователем - диалоги, подсказки и т.п. Например, вывод в диалог эксепшена при неудачном добавлении в базу данных, вывод ошибки доступа к файлу и т.п., что сильно ускоряет отладку. Эта служба\сервис начинает играть очень важную роль, создавая паттерн: оборачивая логики в try..catch с логированием и последующей передачей исключения в службу диалога для показа его пользователю.</p>
<p>Учитывая потенциальные проблемы с Drag-and-drop на разных операционных системах и прочей платформозависимости (буфер обмена и т.п.) есть смысл, по возможности, дублировать критичный или платформозависимый функционал.</p>
<p>Баг может родиться совершенно неочевидным способом, например, открытие кастомного ColorPicker вызывал падение одного из рабочих столов на Linux, просто убивая его, а DnD временами просто переставал работать.</p>
<p>Возможность наткнуться на баг с загрузкой процессора намекает на необходимость предусмотреть отключение анимации и т.п.</p>
<p>Например, можно учесть невозможность открытия пути в системном обозревателе и добавить возможность его копирования либо заменить на сочетание кнопки (или аналога) и текстового поля, из которого можно скопировать текст. Пострадает дизайн, но появляется альтернативный способ решения проблемы, хотя бы и в ручном режиме. Если же сделать путь в виде некопируемой ссылки, то в случае невозможности её открытия в системе о вас очень плохо вспомнят.</p>
<p>Что касается украшательств, то CSS-тему возможно собрать через Sass. Не могу сказать о совсем новых Dart-версиях, которые используют модульный подход, но такая сборка вполне удобна, особенно вместе с вотчером, который перегружает файл темы.</p>
<p>Весьма хорошо себя зарекомендовало окно в приложении со всеми контролами темы, которое можно открыть для отладки и проверки ошибок после правки CSS-файла. С другой стороны, если какая-либо дополнительная проверка FXML-файлов осуществляется на этапе запуска приложения, то такой убер-шаблон может потребовать много ресурсов.</p>
<p>Так как кроссплатформенные баги потенциально бесконечны, то в приложении есть смысл продумать хорошую систему логирования и перехвата ошибок, чтобы случайно не потерять исключение, это очень критичный участок. Стоит помнить, что исключение может прилететь из JavaFX-потока, причем несколько подряд.</p>
<p>В условиях современной Java можно создать модульное приложение. При этом в module-info может потребоваться открыть свои контроллеры к javafx.fxml для использования FXML-аннотаций. Разброс контроллеров по пакетам осложняет данную не очень веселую процедуру. Это касается и других случаев, например, заполнения JavaFX-таблиц через рефлексию, а может повлиять и на систему плагинов, например, на интеграцию Groovy.</p>
<p>Здесь также появляется новая беда: всяческие вариации модульных конфликтов библиотек с приложением, друг с другом и просто так. На компиляцию, а особенно на запуск JavaFX приложения могут влиять очень много факторов: модульность, сборщик, IDE и т.п., создавая большой количество комбинаций.</p>
<p>В случае проблем проще держаться проверенного алгоритма: заставить работать заведомо рабочий код из <a href="https://github.com/openjfx/samples">репозиториев примеров</a> либо с сайта тулкита. А после получения работоспособного примера натягивать на него свой код, ломая его, не наоборот.</p>
<p>Если случайно взятая библиотека сложная, давно не обновлялась или же поддерживает высокий уровень совместимости со старыми версиями Java (а обычно так и делается), то нужно ждать беды. Есть различные плагины для автоматической модуляризации, например, <a href="https://github.com/moditect/moditect">moditect</a>, <a href="https://github.com/gradlex-org/extra-java-module-info">extra-java-module-info</a> и т.п. А можно просто удалить модульность из приложения.</p>
<p>С другой стороны, модульность снимает давнюю проблему JavaFX - сложность деплоя. Плагины навроде <a href="https://github.com/beryx/badass-jlink-plugin">badass-jlink-plugin</a> могут создавать легковесные рантаймовые JVM-образы со скриптами запуска в комплекте, делать установщики, паковать в архив и прочее.</p>
<p>Конечно же, с некоторыми из этих проблем, перечисленных выше, можно и не столкнуться, а для кого-то это не является проблемой вообще, особенно при выборе иной архитектуры или добровольном принятии рисков. Вариантов здесь очень много и всё зависит от задач приложения и конкретной ситуации.</p>
<p>Но знакомство с потенциальными сложностями все равно может быть полезным, например, для прогнозирования других неприятностей по аналогии. Так или иначе, но надеюсь это поможет вам меньше наступать на грабли и сэкономить своё время.</p>
</div>
    </div>
</article>
<div class='navigation-pages btn-toolbar justify-content-center mb-2' role='navigation'>
    
    <a class='navigation-pages-link btn mb-2 mx-0 mx-sm-1'
       href='/pages/marketing-for-developer.html' role='button' rel="prev"> <span
            class='navigation-pages-link-icon mdi mdi-chevron-left'></span> Программирование и маркетинг</a>
    
    <a class='navigation-pages-link btn mb-2 mx-0 mx-sm-1' href='/index.html'
       role='button' rel="first">
        <span class='navigation-pages-link-icon mdi mdi-home'></span> Главная</a>

    
    <a class='navigation-pages-link btn mb-2 mx-0 mx-sm-1'
       href='/pages/traits-and-architect.html' role='button' rel="next">Влияние трейтов на архитектуру <span
            class='navigation-pages-link-icon mdi mdi-chevron-right'></span></a>
    
</div>
        </div>
        <div class='col-lg-3 sidebar-right'>
            <div class='section' id='section-sidebar-right'>
    <div class='card sidebar-container post-labels'>
        <div class='card-header sidebar-container-header post-labels-header'>
            <span class='post-labels-header-icon mdi mdi-tag-outline'></span>
            Метки <span class='text-clarification'>(и кол-во статей)</span>
        </div>
        <div class='sidebar-container-content post-labels-content'>
            <div class='list-group list-group-flush'>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/dart.html'>Dart<span class='badge' style='min-width:40px;'>2</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/dlang.html'>Dlang<span class='badge' style='min-width:40px;'>3</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/groovy.html'>Groovy<span class='badge' style='min-width:40px;'>5</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/javafx.html'>JavaFX<span class='badge' style='min-width:40px;'>6</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/arhitektura_po.html'>Архитектура ПО<span class='badge' style='min-width:40px;'>10</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/metodologija.html'>Методология<span class='badge' style='min-width:40px;'>2</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/raznoe.html'>Разное<span class='badge' style='min-width:40px;'>1</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/ekonomika.html'>Экономика<span class='badge' style='min-width:40px;'>3</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/elektronika.html'>Электроника<span class='badge' style='min-width:40px;'>1</span></a>
                
            </div>
        </div>
    </div>
    <div class='card sidebar-container in-progress-articles'>
       <div class='card-header sidebar-container-header in-progress-articles-header'>
           <span class='mdi mdi-calendar-clock'></span>
            В процессе написания
       </div>
       <div class='sidebar-container-content post-labels-content in-progress-articles-content'>
               <ul class='list-group'>
				   <li class='list-group-item align-items-center text-muted'>Нет статей</li>
               </ul>
       </div>
    </div>
    <div class='card mb-3 sidebar-container links-contacts'>
        <div class='card-header sidebar-container-header links-contacts-header'>
            <span class='mdi mdi-account-outline'></span>
            Бортовые журналы текущих проектов
        </div>
        <div class="list-group sidebar-container-content">
			<a class='link-contact list-group-item list-group-item-action' rel="me" href='https://vk.com/initkfs'>ВКонтакте (основной)</a>
			<a class='link-contact list-group-item list-group-item-action' rel="me" href='https://www.youtube.com/@initkfs'>Youtube (готовится)</a>
		</div>
    </div>
    <div class='page-up-wrapper'>
        <button class='btn d-none d-lg-block' id='page-up-trigger' type='button'><span
                class='mdi mdi-arrow-up'></span></button>
    </div>
</div>
        </div>
    </div>
</div>
<footer class='page-footer'>
    <div class='container'>
        <div class='row'>
            <div class='col-md-12'>
                <div class='card'>
    <div class='card-body'>
        <p class="text-danger">Сайт в процессе тестирования.</p>
        <small><span class='blog-info-footer'>Всего статей: 24. Блог носит исследовательский характер: я могу заблуждаться, ошибаться или чего-то не знать. Все статьи отражают лишь моё субъективное мнение, не более.</span> <span>&#169; <span id='copyright-date'></span> Все права
                  защищены.</span></small>
        
        <div class='blog-additional-links d-flex justify-content-center'>
        <div class='blog-rss'><a class='blog-rss-item blog-icon-clickable'
                                 href='/rss-all.xml'><span
                class='mdi mdi-rss-box blog-icon-rss'></span></a></div>
        </div>
        <div class='text-danger' id='js-fail-block'>
            <noscript>
                <small>JavaScript отключен в браузере, функционал сайта ограничен.</small>
            </noscript>
        </div>
    </div>
</div>
<script type='application/ld+json'>
    {
        "@context": "http://www.schema.org",
        "@type": "person",
        "name": "initkfs",
        "jobTitle": "",
        "url": "/index.html"
    }
</script>
            </div>
        </div>
    </div>
</footer>
<div class='mobile-up-wrapper text-center'>
    <button class='btn d-lg-none' id='mobile-page-up-trigger' type='button'><span
            class='mdi mdi-arrow-up'></span> Вверх
    </button>
</div>
<script src="https://code.jquery.com/jquery-3.7.1.min.js" 
integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

<script crossorigin='anonymous' integrity='sha512-TPh2Oxlg1zp+kz3nFA0C5vVC6leG/6mm1z9+mA81MI5eaUVqasPLO8Cuk4gMF4gUfP5etR73rgU/8PNMsSesoQ=='
        src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js'></script>

<script crossorigin='anonymous' integrity='sha512-WW8/jxkELe2CAiE4LvQfwm1rajOS8PHasCCx+knHG0gBHt8EXxS6T6tJRTGuDQVnluuAvMxWF4j8SNFDKceLFg=='
        src='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.min.js'></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/timeago.js/4.0.2/timeago.full.min.js" integrity="sha512-wb3lqal2VtYhmlPAr232VP+Zus676CFAEYdywxIUSxG6F/X9WhN6SpREkWUdwBvMpd6gCKuKTGHhdum6m1wOvQ==" crossorigin="anonymous"></script>

<script crossorigin='anonymous' integrity='sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q=='
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>

<script crossorigin='anonymous' integrity='sha512-SkmBfuA2hqjzEVpmnMt/LINrjop3GKWqsuLSSB3e7iBmYK7JuWw4ldmmxwD9mdm2IRTTi0OxSAfEGvgEi0i2Kw=='
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" ></script>

<script>
var problemScripts = [];
if (typeof jQuery === 'undefined') {
    problemScripts.push("jquery");
}

   if (typeof Prism === 'undefined'){
    problemScripts.push("prism.js");
   }
   
if (typeof Popper === 'undefined') {
    problemScripts.push("popper.js");
}

if (typeof timeago === 'undefined') {
    problemScripts.push("timeago.js");
}

if (typeof window.bootstrap === 'undefined') {
    problemScripts.push("bootstrap.js");
}

if (problemScripts.length > 0) {
    var message = "Ошибка загрузки JavaScript: " +
        problemScripts.join(",") +
        "." +
        " Возможные причины: блокировщик рекламы, проблемы с сетью, устаревший браузер. Может не работать дополнительный функционал.";

    var failInfoBlock = document.createElement("small");
    failInfoBlock.innerHTML = message;

    var mainFailBlock = document.getElementById("js-fail-block");
    if (!mainFailBlock) {
        console.error(message);
    } else {
        mainFailBlock.appendChild(failInfoBlock);
    }   
}
</script>
<script src="/assets/dev/js/main.js"></script>
</body>
</html>



