<!doctype html>
<html lang="ru">
<head>
    <meta charset='utf-8'>
    <meta name="yandex-verification" content="7021eeb9c07b5c09">
    <meta name="google-site-verification" content="PztbVe6Ru8ggM2n_tWUYwy0bEVHtJNvzIr-nsVCvBCA">
    
    
    <meta content='width=device-width, initial-scale=1' name='viewport'>
    <!-- favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="/assets/stab/img/favicons/favicon.ico">
    <link rel="icon" type="image/png" href="/assets/stab/img/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/assets/stab/img/favicons/favicon-16x16.png" sizes="16x16">
    <link rel="mask-icon" href="/assets/stab/img/favicons/safari-pinned-tab.svg" color="#004245">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/stab/img/favicons/apple-touch-icon.png">
    <meta name="msapplication-config" content="/assets/stab/img/favicons/browserconfig.xml">
    <!-- end favicons -->
    <!-- rss feeds -->
    <link rel=alternate title="RSS лента" type=application/rss+xml href='/rss-all.xml'>
    <!-- end rss feeds -->
    <link type="text/plain" rel="author" href="/humans.txt">
    <link crossorigin='anonymous' href='https://cdn.materialdesignicons.com/3.5.95/css/materialdesignicons.min.css'
          integrity='sha384-Ls5zBitvvQ/wdeZDuTUevSY5Tb/she50BeMPrco2ok6xDC8modj6/JPwdL0gNxmP' rel='stylesheet'>
    
    <link crossorigin='anonymous' integrity='sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ=='
          href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    
    <link href="/assets/dev/css/main.css" rel='stylesheet'>
    
    <title>Индукция Бэкона-Милля или поиск причины бага методом тыка. Космическая станция Аналитики - DIY техноблог о сложных IT-проектах</title>
    <meta name="description" content="Описание методов Бэкона-Милля для поиска причины багов">
    <meta content='Индукция Бэкона-Милля или поиск причины бага методом тыка. Космическая станция Аналитики - DIY техноблог о сложных IT-проектах' property='og:title'>
    
    <meta name="keywords" content="индукция,методы бэкона-милля">
    
    <meta content='/index.html' property='og:url'>
    <meta content='website' property='og:type'>
    <meta content='ru_RU' property='og:locale'>
</head>
<body>
<div class='container mb-3'>
    <div class='row'>
        <div class='col-lg-12'>
           <div class='card w-100 site-header-container'>
    <div class='row align-items-center'>
        <div class="col-lg-9">
            <div class='card-header site-header'>
                <div class='card-title site-header-title mb-3'>
                    <h5 class='site-header-title-text'>
                        <a href='/index.html' class='blog-title-text-link'>Космическая станция Аналитики - DIY техноблог о сложных IT-проектах</
                    </h5>
                </div>
                <div class='card-subtitle site-header-subtitle mb-2'>
                     <a href="/pages/about.html" class="badge mb-2 mb-sm-0">О станции и капитане</a>  <a href="/pages/site-implementation.html" class="badge">Сайт (Groovy-генератор)</a> 
                </div>
            </div>
        </div>
        <div class="col-lg-3">
            
            <div class='site-map w-100 d-flex justify-content-center pe-lg-3'>
                <a class='site-map-link btn w-100' href='/site-map.html' role='button'><span
                        class='site-map-link-icon mdi mdi-sitemap'></span>
                    <span class='text-clarification'>Карта сайта (все статьи)</span></a>
            </div>
            
        </div>
    </div>
</div>
        </div>
    </div>
</div>
<div class='container'>
    <div class='row'>
        <div class='col-lg-9 blog-posts'>
            <article class='card post'>
    <h5 class='card-header post-header fw-bold'>
        Индукция Бэкона-Милля или поиск причины бага методом тыка
    </h5>
    <div class='card-body post-body'>
        <div class="card-title mb-3">
            <div class="post-body-header">

<div class='post-header-date'><span class='mdi mdi-calendar-clock'></span>
    <span class="post-datetime-text" data-iso-time="2019-10-05">5 октября 2019</span>
</div>


<span class='mdi mdi-code-braces'></span><span> Примеры кода</span>
<div class='post-labels'>
    <span class='post-header-labels-icon mdi mdi-tag-outline'></span>
    
    <a class='post-label-item badge font-weight-normal'
       href='/tags/metodologija.html' rel='tag'>Методология
    </a>
    
</div>
</div>
        </div>
        <div class='post-content'><ol>
<li><a href="#method_induction">Введение, индукция</a></li>
<li><a href="#method_induction_similarity">Метод единственного сходства</a></li>
<li><a href="#method_induction_difference">Метод единственного различия</a></li>
<li><a href="#method_induction_combined">Объединенный метод сходства и различия</a></li>
<li><a href="#method_induction_changes">Метод сопутствующих изменений</a></li>
<li><a href="#method_induction_remainder">Метод остатков</a></li>
<li><a href="#method_induction_examples">Примеры</a></li>
<li><a href="#сonditionally_categorical_syllogism">Условно-категорический силлогизм</a></li>
<li><a href="#method_induction_sum">Выводы</a></li>
</ol>
<h5><a name="method_induction"></a>Введение, индукция</h5>
<p>Когда мы сталкиваемся с багами или странным поведением кода, то первым делом начинаем устанавливать причину происходящего. В самом простом случае хорошо работает известный прием &quot;закомментировал-запустил-раскомментировал&quot;. По мере увеличения количества зависимостей справиться с ситуацией становится всё тяжелее. Особенно это характерно для предметно-ориентированных (DSL) языков, где малый отклик от кода может привести к большим потерям времени и за что многие сильно их не любят.</p>
<p>Но даже в тяжелых случаях часто используется экспериментальный метод &quot;тыка&quot; - перебор любых значений на которые можно как-то повлиять или изменить с наблюдением результата. Вспомним о методологии, которая лежит в самой основе.</p>
<p>На самом деле есть отдельная теория познания, тесно связанная с логикой, философией и другими науками, отчего всё это приобретает разбросанный характер знаний. Однако при специализации методы обычно теряют в своей универсальности, а нас, конечно же, интересуют самые простые и общие основы, применимые для самых разных случаев, поэтому мы рассмотрим их ровно так, как это подается почти в каждом учебнике по логике.</p>
<p>Чтобы не вырывать методологию из контекста вспомним из базового курса логики несколько определений.</p>
<p><strong>Форма мышления</strong> - способ связи элементов мысли, выражающий её структуру и содержание. К формам мышления относятся понятие, суждение и умозаключение. Нас интересует умозаключение.</p>
<p><strong>Умозаключение</strong> – это форма мышления, с помощью которой из ранее установленных знаний можно получить новое знание разной степени достоверности. Они бывают дедуктивные - от общего к частному, индуктивные - от частного к общему и традуктивные (умозаключение по аналогии) - от знания к знанию такого же уровня. Нас интересуют индукция.</p>
<p>Часто <strong>индукцию</strong> делят на полную и неполную, добавляя и более специализированные виды, например, математическую. Остановимся на первых двух:</p>
<ul>
<li>Полная индукция - общий вывод обо всех элементах делается на основании рассмотрения каждого элемента, т.е. изучаются <strong>все</strong> предметы данного класса. Выводы носят достоверный характер.</li>
<li>Неполная индукция – на основании повторяемости признака у некоторых элементов множества делается заключение о его принадлежности всем элементам. Вывод не является достоверным.</li>
</ul>
<p>Нас интересует неполная индукция, её виды:</p>
<ul>
<li>Популярная - простое перечисление при отсутствии противоречащего случая.</li>
<li>Научная (индукция путем отбора) - обобщение строится путем отбора необходимых и исключения случайных обстоятельств. Научная индукция пытается повысить достоверность выводов неполной индукции различными специальными методами.</li>
</ul>
<p>Научная индукция, в свою очередь, бывает:</p>
<ul>
<li>Селективная - планомерный и целенаправленный отбор, на основе определенной системы критериев.</li>
<li>Индукция методом исключения (элиминативная) – обнаружение подтверждающих обстоятельств и исключения обстоятельств, не удовлетворяющих свойствам причинной связи.</li>
</ul>
<p>Последняя особенно явно подводит нас к понятию причин и следствий, которые опираются на интуитивные и простые постулаты:</p>
<ul>
<li>Каждое явление имеет причину, которую можно и нужно установить.</li>
<li>Причина наступает во времени раньше, чем следствие.</li>
<li>После причины непременно наступает следствие.</li>
<li>При отсутствии причины следствие не наступает.</li>
<li>Изменения в причине приводят к соответствующим изменениям в следствии.</li>
</ul>
<p>Нас как раз таки и интересуют эти методы установления причинно-следственных связей, которые часто называют методами Бэкона-Милля, по именам их разработчиков. Даже саму научную индукцию иногда называются индукцией Бэкона-Милля (или Каноны Милля).</p>
<p>В методы Бэкона-Милля входят:</p>
<h5><a name="method_induction_similarity"></a>Метод единственного сходства</h5>
<p>Если обстоятельство постоянно предшествует исследуемому явлению при изменении всех других обстоятельств, то вероятно, что именно оно и является причиной этого явления.</p>
<p>Примерный алгоритм:</p>
<ul>
<li>Определить все случаи с явлением <em>a</em>, причина которого неизвестна.</li>
<li>Выделить все обстоятельства, связанные с появлением явления <em>a</em>.</li>
<li>Найти общее для всех случаев обстоятельство. Именно оно, вероятно, и будет причиной появления явления <em>a</em>.</li>
</ul>
<p>Формально:<br/>АВС→а<br/>АDЕ→а<br/>АКМ→а<br/>----------------------<br/>◊(А→а), где ◊ - оператор возможности из модальной логики, подразумевает вероятностный характер вывода</p>
<p>Следовательно, обстоятельство А, вероятно, является причиной явления <em>а</em>. Общим для всех случаев было обстоятельство A.</p>
<h5><a name="method_induction_difference"></a>Метод единственного различия</h5>
<p>Если определенное обстоятельство присутствует тогда, когда имеет место исследуемое явление, и отсутствует тогда, когда это явление отсутствует (а все другое остается неизменным), то именно это обстоятельство и является вероятной причиной исследуемого явления.</p>
<p>Примерный алгоритм:</p>
<ul>
<li>Рассмотреть два случая, в одном из которых исследуемое явление <em>a</em> наступает, а во втором — не наступает.</li>
<li>Сравнить эти случаи и выявить обстоятельства, которые им предшествовали.</li>
<li>Выявить общие обстоятельства и обстоятельство, которое отсутствует в случае, когда явление <em>а</em> не наступает. Именно оно и будет причиной его появления.</li>
</ul>
<p>Формально:<br/>АВСD→а<br/>ВСD→<br/>----------------------<br/>◊(А→а)</p>
<p>К сожалению, методы единственного сходства и единственного различия очень ненадежны на практике и приводятся часто лишь для демонстрации основы метода, который является их комбинацией:</p>
<h5><a name="method_induction_combined"></a>Объединенный метод сходства и различия</h5>
<p>Если два (или более) случая, в которых имеет место исследуемое явление, сходные только одним обстоятельством, которое предшествует возникновению этого явления, а два (или более) случая, в одном из которых это явление отсутствует, а в другом присутствует, отличаются только отсутствием (присутствием) этого обстоятельства, то, вероятно, это обстоятельство и является причиной исследуемого явления.</p>
<p>Примерный алгоритм:</p>
<ul>
<li>Рассмотреть несколько случаев, в которых наступает явление <em>а</em>. Эти случаи во всем отличны и только схожи в одном обстоятельстве А.</li>
<li>Рассмотреть несколько случаев, в которых не наступает явление <em>а</em>. Эти случаи отличаются от предыдущих тем, что в них отсутствует общее обстоятельство А.</li>
</ul>
<p>Формально:<br/>АВС→a           АВСD→а<br/>АDЕ→а           ВСD→<br/>----------------------<br/>◊(А→а)</p>
<h5><a name="method_induction_changes"></a>Метод сопутствующих изменений</h5>
<p>Если при изменении одного из обстоятельств, которые предшествуют возникновению исследуемого явления, изменяется и само явление, то вероятно, что именно это обстоятельство и является причиной этого явления.</p>
<p>Примерный алгоритм:</p>
<ul>
<li>Рассмотреть случай, когда возникает явление <em>а</em>, и выявить обстоятельства, присущие ему.</li>
<li>Изменить несколько раз одно из обстоятельств и посмотреть, изменяется ли явление <em>а</em>. Если каждый раз изменялось и явление <em>а</em>, то, вероятно, это обстоятельство и является причиной возникновения этого явления.</li>
</ul>
<p>Формально:<br/>АВСD→аbcd<br/>А<sub>1</sub>ВCD→а<sub>1</sub>bcd<br/>А<sub>2</sub>BСD→а<sub>2</sub>bcd<br/>...<br/>А<sub>n</sub>BСD→а<sub>n</sub>bcd	<br/>----------------------			<br/>◊(А→а)</p>
<p>К сожалению, из-за большого количества зависимостей для любого явления отделить изменение причины и следствия достаточно трудно. Поэтому вне технических наук этот метод может легко дать ошибочный результат.</p>
<h5><a name="method_induction_remainder"></a>Метод остатков</h5>
<p>Если сложные обстоятельства обусловливают сложное явление и известно, что часть обстоятельств вызывает определенную часть этого явления, то оставшиеся обстоятельства вызывают оставшуюся часть явления.</p>
<p>Здесь даже стоит привести классический пример, наиболее часто я встречал описание открытия планеты Нептун. До его открытия движение Урана рассчитывалось с предположением о том, что единственными небесными телами, которые влияли на него были Солнце и планеты в орбите самого Урана. Однако рассчитываемое местоположение Урана не совпадало с расчётами. Была выдвинута гипотеза о существовании неизвестной планеты, гравитационное поле которой и обуславливало эти различия, определено её примерное положение и недалеко от этого места в 1846 году был обнаружен Нептун.</p>
<p>К сожалению, метод остатков считают самым слабым из известных методов научной индукции. Эффективность его очень сильно зависит от независимости обстоятельств, составляющих явление. Если эти обстоятельства зависят друг от друга, то всё становится намного сложнее.</p>
<p>Примерный алгоритм:</p>
<ul>
<li>Сложное явление <em>ab</em> обусловлено обстоятельствами AB.</li>
<li>Явление <em>а</em> возникает по причине обстоятельства А.</li>
<li>Следовательно, В, вероятно, является причиной <em>b</em>.</li>
</ul>
<p>Формально:<br/>АВС→аbc<br/>А→а<br/>B→b<br/>----------------------<br />
◊(С→с)</p>
<h5><a name="method_induction_examples"></a>Примеры</h5>
<p>Что можно сказать о самой методологии. Она совершенно не отвечает на вопрос, каким способом нужно проводить анализ и выдвигать гипотезу о зависимости, которую затем проверять с помощью методов индукции. При большом количестве различных явлений достаточно трудно управлять их анализом, поэтому можно грубо предположить, что в случае более низкоуровневых языков это сделать проще за счет их пошагового характера. Среди языков с наиболее меньшим количеством зависимостей является язык ассемблера (ну, или ассемблеры в случае трансляторов), а так как наиболее прост он в обращении под Linux, то я буду использовать NASM для 64-разрядной системы. Я не рассматриваю сборку и запуск - это легко гуглится, а комментировать буду над вызовами, иначе на мобильных устройствах за счет большой ширины кода это всё некрасиво поедет. Кроме того, я буду придерживаться краткости, (например, помещать в регистр единицу напрямую вместо инкремента) и ориентироваться на сборку через GCC, ибо последние версии идут с дефолтным PIE\PIC, что требует некоторой доработки кода.</p>
<p>Давайте вспомним очень частую ошибку, связанную с различием между вызовом функции\метода в высокоуровневом языке. Мы просто распечатаем число с вызовом ptintf, но изначально поместим переменную в регистр Rx, чтобы они хранились в регистрах, на первый взгляд, не задействованных напрямую при вызове. Мы знаем (<a href="https://ru.stackoverflow.com/questions/435230/nasm-printf-функция">нагуглили</a>, прочитали), что для вызова потребуется RDI - для паттерна, RSI - для значения и обнуленный RAX для возврата результата вызова. Мы может получить что-то вроде этого:</p>
<pre class='line-numbers'><code class='prettyprint language-nasm'>; Секция данных
section .data

; db - данные как последовательность байт. 10 - перенос строки, 0 - нулевой байт, конец строки. Но NASM понимает и `Message=%d\n`
messageFormat: db &quot;Message=%d&quot;, 10, 0

; Секция кода
section .text

; Объявляем точку входа. В зависимости от способа сборки точка входа может изменяться.
global main

printNumber:
; Здесь, в прологе процедуры нам не нужен стековый фрейм, обойдемся без выравнивания и переменных
; Значение для печати должно находится в RSI, мы сделаем это в main
; Помещаем в RDI адрес паттерн сообщения 
mov rdi, messageFormat

; Обнуляем RAX для предотвращения сегфолта. Конечно же, похожий аналог: mov rax, 0
xor rax, rax
; Вызываем printf, в последних версиях GCC по умолчанию включен позиционно-независимый код, поэтому обычный вызов приведет к ошибке. Ну, или нужно отключать через -no-pie.
call printf WRT ..plt
; После вызова стоит проверить RAX на наличие отрицательного числа - признак ошибки и что-нибудь сделать.
; Выходим из процедуры
ret

; Точка входа
main:
; Помещаем в регистр R8 число 5, чтобы число было в регистре, не задействованном при вызове printf.
mov r8, 5

; В RSI число 5
mov rsi, r8
; Печатаем 5
call printNumber

; Метка с точкой, локальная для main
.exit:
; Помещаем в RDX код выхода, под Linux он 0&lt;= и &lt;=255. В данном случае мы не проверяли ошибки и обнуляем его, в ином случае терять ошибки, конечно же, нельзя
xor rdx, rdx
; Помещаем номер вызова sys_exit из ядра: https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
mov rax, 60 
; Запрашиваем выход из программы 
syscall
</code></pre>
<p>Итак, мы ожидаем печати числа 5. Запустим в терминале и убедимся, что это действительно так:</p>
<pre class='line-numbers'><code class='prettyprint language-'>Message=5
</code></pre>
<p>Усложним задачу и сделаем два вызова подряд</p>
<pre class='line-numbers'><code class='prettyprint language-nasm'>
mov r8, 5
mov r9, 6

; В RSI число 5
mov rsi, r8
; Печатаем 5
call printNumber

; В RSI число 6
mov rsi, r9
; Печатаем 6
call printNumber
</code></pre>
<p>Мы ожидаем распечатать два числа 5 и 6. Что мы видим, регистр R9 где-то потерялся:</p>
<pre class='line-numbers'><code class='prettyprint language-'>Message=5
Message=1849455520
</code></pre>
<p>За счет пошаговой природы ассемблера достаточно легко выявить проблему, закомментировав часть строк. Обычно комментируется большой кусок кода, потом меньше и меньше, напоминая своей природой чем-то двоичный поиск. У нас немного зависимостей, поэтому комментируем первый вызов т.к. первый вызов дал правильный результат.</p>
<pre class='line-numbers'><code class='prettyprint language-nasm'>
mov r8, 5
mov r9, 6

; В RSI число 5
; mov rsi, r8
; Печатаем 5
; call printNumber

; В RSI число 6
mov rsi, r9
; Печатаем 6
call printNumber
</code></pre>
<p>Используем методы выше и полностью комментируем первый вызов и наблюдаем, что в регистре R9, а значит и в RSI действительно число 6</p>
<pre class='line-numbers'><code class='prettyprint language-'>Message=6
</code></pre>
<p>Раскомментируем снова и получаем неправильный ответ. Здесь явная зависимость от вызова call, при появлении вызова или его отсутствии проблема появляется и исчезает соответственно. Далее мы можем уточнить в процедуре, что вызов printf каким-то образом теряет регистры, загуглить и почитать, что регистры вполне себе могут теряться вплоть до R11. Но за счет простого комментирования мы быстро выявили проблему.</p>
<p>Метод сопутствующих изменений достаточно ясен, а вот метод остатков попробуем натянуть на данный код. Не уверен, что это будет хорошим примером, но попробуем распечатать теперь число с плавающей точкой. Нельзя так просто взять и поместить его в регистр, но можно инициализировать переменную, причем она должна быть размером не меньше чем dword т.е. не менее 4 байт. Используем 8-байтный тип qword по величине регистра, чтобы не иметь проблем с разными размерами и поменяем спецификатор формата для printf на %f:</p>
<pre class='line-numbers'><code class='prettyprint language-nasm'>section .data
messageFormat: db &quot;Message=%f&quot;, 10, 0
; Используем директиву задания исходных данных для qword - dq.
floatNumber: dq 123.45
</code></pre>
<p>Теперь нам нужна прямая адресация, которая в NASM задается скобками, поместим в регистр RSI наше число, учитывая требования PIC используем rel и попытаемся напечатать:</p>
<pre class='line-numbers'><code class='prettyprint language-nasm'>
; В RSI число 123.45
mov rsi, [rel floatNumber]
; Печатаем 123.45
call printNumber
</code></pre>
<p>Запускаем:</p>
<pre class='line-numbers'><code class='prettyprint language-'>Message=0.000000
</code></pre>
<p>И здесь уже более серьезная проблема. Попробуем выявить зависимости. В процедуре и процессе печати не слишком их много:</p>
<ul>
<li>Помещение значения числа в регистр RSI</li>
<li>Вызов нашей процедуры</li>
<li>Помещение паттерна в RDI</li>
<li>Обнуление RAX</li>
<li>Вызов printf</li>
<li>Выход</li>
</ul>
<p>Вычеркнем события, который происходят при любой процедуре - вызов, выход и т.п.</p>
<ul>
<li>Занесение числа в регистр RSI</li>
<li>Обнуление RAX</li>
</ul>
<p>Если мы рассмотрим их по алгоритму выше, то эти два события мы не трогали, поэтому можно предположить, что проблема кроется в каком-то из них, они вызывают ошибку, когда как другие события мало влияют на её появления, они слишком очевидны. Здесь уже можно сформулировать запрос в Google и узнать, что число должно быть в специфическом регистре, а RAX требует 1. На самом деле, конечно же, это можно было бы загуглить и сразу.</p>
<p>Исправляем, проще использовать регистр расширения SSE, но так как он 128-битный, то мы используем movq для пересылки 64-битного нашего числа типа qword:</p>
<pre class='line-numbers'><code class='prettyprint language-nasm'>section .data
messageFormat: db &quot;Message=%f&quot;, 10, 0
floatNumber: dq 123.45

section .text

global main

printNumber:
mov rdi, messageFormat
mov rax, 1
call printf WRT ..plt
ret

main:
; В xmm0 число 123.45
movq xmm0, [rel floatNumber]
; Печатаем 123.45
call printNumber

.exit:
mov rdi, 0
mov rax, 60 
syscall
</code></pre>
<p>Итог:</p>
<pre class='line-numbers'><code class='prettyprint language-'>Message=123.450000
</code></pre>
<p>Да уж, такой себе пример, но, думаю, Вы поняли принцип аналогии. На самом деле он не только притянутый за уши, но и надуманный, мы ничего не знаем - зависимые ли там события или нет. Всё это достаточно неочевидно и если такое происходит в простом ассемблере, то что будет в сложном высоко абстрактном языке в условиях тысяч классов убер-фреймворка, сборщиков, системных библиотек, особенностей предметной области и просто наличия там множества багов? Логика подсказывает, что в условиях сложных систем нужна адаптация приложения или фреймворка для получения большей обратной связи. Но кому это всё нужно. Попробуйте, например, включить логгер в Spring (который не Boot) и проследить какой-нибудь компонент Spring Security, а потом снова случайно поймаете запрет запросов GET, но разрешенный POST при запрете всех запросов вообще. Отловить это можно скорее лишь агрессивным тестированием.</p>
<h5><a name="сonditionally_categorical_syllogism"></a>Условно-категорический силлогизм</h5>
<p>Стоит отметить, что поиск подобных зависимостей тесно соприкасается с условно-категорические силлогизмом и его модусами. Не буду занудствовать с определениями, они интуитивны. Например, в части проблем с распечаткой рационального числа мы получили 0 в итоге. Попробуем сформулировать ход дел:</p>
<ul>
<li>Если процедура printNumber запускается с числом 123.45.</li>
<li>В консоль печатается 123.45.<br/>Или: Если A, то B.</li>
</ul>
<p>Конечно, тут подразумевается, что процедура срабатывает корректно и не имеет ошибок. Однако и в этом случае можно сделать неверный вывод. Например, в консоль распечаталось 123.45, можно ли сказать, что процедура printNumber сработала? Нет. Условно-категорический силлогизм имеет только два правильных модуса:</p>
<p><strong>Утверждающий модус или modus ponens: от утверждения основания к утверждению следствия:</strong><br/>Если A, то B<br/>A<br/>----------------------<br/>B<br/>Т.е. мы можем сказать, что если корректная процедура точно запустилась, то в консоль будет напечатано число.</p>
<p><strong>Отрицающий модус, он же modus tollens: от отрицания следствия к отрицанию основания:</strong><br/>Если A, то B<br/>Не B   	<br/>----------------------<br/>Не A	<br/>Т.е. мы можем сказать, что если в консоль не выводится наше число, то процедура не запускалась (напомню, что мы предполагаем её корректность)</p>
<p>А вот дальше интереснее и рождается серьезная опасность принять вероятностные выводы за правдоподобные, чему способствуют следующие модусы:<br/>Если A, то B<br/>B 	<br/>----------------------<br/>Вероятно, A<br/>Это очень коварная ловушка. Действительно, если распечатывается число, то могла сработать совершенно другая процедура или не выполняться вообще. В топе источников проблем находятся побочные эффекты кэшей и баги сборки. Скрипт сборки и запуска может иметь ошибку и запускать старый код вместо нового, например, неправильно определяя время изменения файла или иметь ошибку парсинга его имени. Мы комментируем вызов процедуры, но за счет того, что исполняется старый код все равно получаем в консоль наше злосчастное число. Такие ситуации встречаются повсеместно и наиболее коварны из них те, которые визуально не нарушают методы индукции, изящно маскируя проблему. Технически, проблемы с кэшем или сборкой способны исказить картину любых модусов в т.ч. правильных, но я все же должен был вспомнить об этом.</p>
<p>И похожий модус на предыдущий:<br/>Если A, то B<br/>Не-A<br/>----------------------<br/>Вероятно, не-B	<br/>Если процедура не запускается, то число все равно может распечататься по причинам выше.</p>
<h5><a name="method_induction_sum"></a>Выводы</h5>
<p>Таким образом, данная методология индукции вводит хотя бы и примитивную, но всё-же системность в тыкание по коду. К сожалению, использование сложных математических методов, как правило, слабо  применимо из-за неравномерного уровня восприятия, внимания, памяти, мышления и т.п. психологических процессов, поэтому самые простые идеи, как правило, часто могут спасти ситуацию. Кроме того, их рассмотрение полезно еще с одной стороны. В глаза бросается некая связь с количеством зависимостей и отловом багов. Чем больше менее важных событий мы можем отбросить, тем быстрее начнем экспериментировать с важными, которые скорее всего и будут причиной бага. В части примеров выше я сразу отбросил помещение в регистры адреса, выход из процедуры и т.п. Поэтому вспомним заодно о <a href="https://ru.wikipedia.org/wiki/Контрактное_программирование">контрактном программировании</a>.</p>
<p>В коде выше нет удобного способа узнать, что делает, а чего не делает printf. Нам следовало бы задекларировать для нашей обертки printNumber: вход, выход, сохранение регистров, использование макросов, вызов других процедур, обращение к ядру и т.п. с учетом побочных эффектов, чтобы сделать поведение предсказуемым. Но в условиях ассемблера сделать это можно разве что документацией, а любая документация также имеет известные недостатки, увеличивающиеся вместе со сложностью приложения. Неплохо было бы, чтобы на уровне языка мы могли сразу отбрасывать какие-то события, например, побочные эффекты.</p>
<p>С другой стороны, иногда эти же побочные эффекты могут и специально добавляться. Например, в Java (и не только) распространенной практикой является создание иммутабельных коллекций в т.ч. через более простую инициализацию, например, как List.of(1, 2, 3), которые может быть трудно отличить от обычных в коде, однако они имеют совершенно разные контракты. С одной стороны, это может быть оправданным из-за распространенности и каждый разработчик знает, что там может быть внутри, с другой - может привести к минированию приложения, которое подорвётся в рантайме в случайный момент времени. Например, ошибка потери исключения достаточно распространена за счёт перегрузки методов логгера. Вы перехватываете исключение, логируете его что-то вроде log.error(&quot;bla-bla&quot;) вместо log.error(&quot;bla-bla&quot;, e) и оно не выходит за пределы catch блока уже никогда. Это бывает достаточно сложно обнаружить, а в условиях отсутствия статического анализатора или инспекций можно долго думать, что вызывает проблему, ну не добавление же элемента в коллекцию. Обычная практика помещать все эти нюансы в комментарии или покрывать тестами не выдерживает особой критики в условиях сурового боевого, а тем более одиночного программирования.</p>
<p>Противоположный подход развивает, например, D, где кроме непосредственно самих пред\постусловий с инвариантами по сигнатуре метода можно определить есть ли в нём побочные эффекты или изменение состояния, есть ли там опасные операции или нет. Кроме того, D не позволяет мешать изменяемое с неизменяемым и наоборот, хотя и скомпилировать его код сложнее, но в будущем намного проще при поиске бага сразу отбросить многие проблемные ситуации. С другой стороны, агрессивные навязываемые контракты в D могут создать очень серьезные проблемы при переопределении методов или последующем усложнении кода. Как всегда, золотой середины нет и у каждого подхода есть свои недостатки.</p>
<p>К чему я веду. Вышеперечисленные методы поиска причин и следствий, конечно же, очень сильно расходятся с практикой. Кроме того, на это влияет не только язык, но и когнитивные особенности самого разработчика, которые в течении дня обычно нестабильны, связаны с усталостью, сложностью предметной области и другими переменными. Вспомню достаточно показательный случай, который произошел со мной в D, раз уж я упомянул о нём. Работа с сетью в D построена на библиотеке curl. Тестируя приложение в Linux я обнаружил его краш. Ошибка стабильно воспроизводилась при добавлении импорта std.net.curl, сама библиотека с зависимостями была установлена. И тут я пошел по ложному следу. Я думал, что её причина в неправильной сборке и попытке передать неверные флаги компилятору и линкеру. Пробуя разные способы сборки я обнаружил, что dmd файл компилирует без ошибок и предположил, что проблема в неправильной передаче флагов через Dub, начав экспериментировать с ним. Убедившись через лог, что они передаются без ошибок и строка dmd примерно эквивалентна моей строке с одиночного его запуска я начал искать другие различия и наконец-то обнаружил несколько зависимостей, который были подключены в dependencies у dub.json и о которых я совершенно забыл. Одна из них и оказалась причиной, после её удаления всё заработало. Проблема был в том, что её имя содержало слово &quot;lib&quot;, что в сообщении о краше затирало намек на проблему зависимостей, досадно...</p>
<p>С другой стороны, даже метод &quot;тыка&quot;, как мы убедились, можно подвести под какую-то системность, а сам он находит свое отражение и в других концепциях. Будем надеяться, что в скором времени наука изобретёт одновременно эффективные и простые способы, которые можно применять на практике с учетом усталости и снижения внимания, создавая код вообще без каких-либо багов и проблем. На этом пожелании и остановимся.</p>
</div>
    </div>
</article>
<div class='navigation-pages btn-toolbar justify-content-center mb-2' role='navigation'>
    
    <a class='navigation-pages-link btn mb-2 mx-0 mx-sm-1'
       href='/pages/javafx-dead-or-alive.html' role='button' rel="prev"> <span
            class='navigation-pages-link-icon mdi mdi-chevron-left'></span> JavaFX мёртв или жив? Анализ рынка</a>
    
    <a class='navigation-pages-link btn mb-2 mx-0 mx-sm-1' href='/index.html'
       role='button' rel="first">
        <span class='navigation-pages-link-icon mdi mdi-home'></span> Главная</a>

    
    <a class='navigation-pages-link btn mb-2 mx-0 mx-sm-1'
       href='/pages/marketing-for-developer.html' role='button' rel="next">Программирование и маркетинг <span
            class='navigation-pages-link-icon mdi mdi-chevron-right'></span></a>
    
</div>
        </div>
        <div class='col-lg-3 sidebar-right'>
            <div class='section' id='section-sidebar-right'>
    <div class='card sidebar-container post-labels'>
        <div class='card-header sidebar-container-header post-labels-header'>
            <span class='post-labels-header-icon mdi mdi-tag-outline'></span>
            Метки <span class='text-clarification'>(и кол-во статей)</span>
        </div>
        <div class='sidebar-container-content post-labels-content'>
            <div class='list-group list-group-flush'>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/dart.html'>Dart<span class='badge' style='min-width:40px;'>2</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/dlang.html'>Dlang<span class='badge' style='min-width:40px;'>3</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/groovy.html'>Groovy<span class='badge' style='min-width:40px;'>5</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/javafx.html'>JavaFX<span class='badge' style='min-width:40px;'>6</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/arhitektura_po.html'>Архитектура ПО<span class='badge' style='min-width:40px;'>10</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/metodologija.html'>Методология<span class='badge' style='min-width:40px;'>2</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/raznoe.html'>Разное<span class='badge' style='min-width:40px;'>1</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/ekonomika.html'>Экономика<span class='badge' style='min-width:40px;'>3</span></a>
                
                <a class='list-group-item list-group-item-action d-flex justify-content-between align-items-center ' href='/tags/elektronika.html'>Электроника<span class='badge' style='min-width:40px;'>1</span></a>
                
            </div>
        </div>
    </div>
    <div class='card sidebar-container in-progress-articles'>
       <div class='card-header sidebar-container-header in-progress-articles-header'>
           <span class='mdi mdi-calendar-clock'></span>
            В процессе написания
       </div>
       <div class='sidebar-container-content post-labels-content in-progress-articles-content'>
               <ul class='list-group'>
				   <li class='list-group-item align-items-center text-muted'>Нет статей</li>
               </ul>
       </div>
    </div>
    <div class='card mb-3 sidebar-container links-contacts'>
        <div class='card-header sidebar-container-header links-contacts-header'>
            <span class='mdi mdi-open-in-new'></span>
            Девлоги текущих проектов
        </div>
        <div class="list-group sidebar-container-content">
			<a class='link-contact list-group-item list-group-item-action' rel="me" href='https://www.youtube.com/@initkfs'>Youtube (готовится)</a>
		</div>
    </div>
    <div class='page-up-wrapper'>
        <button class='btn d-none d-lg-block' id='page-up-trigger' type='button'><span
                class='mdi mdi-arrow-up'></span></button>
    </div>
</div>
        </div>
    </div>
</div>
<footer class='page-footer'>
    <div class='container'>
        <div class='row'>
            <div class='col-md-12'>
                <div class='card'>
    <div class='card-body'>
        <p class="text-danger">Сайт в процессе тестирования.</p>
        <small><span class='blog-info-footer'>Всего статей: 24. Блог - исследовательский, статьи отражают лишь субъективное мнение автора.</span> <span>&#169; <span id='copyright-date'></span>, Константин Фирсов.</span></small>
        
        <div class='blog-additional-links d-flex justify-content-center'>
        <div class='blog-rss'><a class='blog-rss-item blog-icon-clickable'
                                 href='/rss-all.xml'><span
                class='mdi mdi-rss-box blog-icon-rss'></span></a></div>
        </div>
        <div class='text-danger' id='js-fail-block'>
            <noscript>
                <small>JavaScript отключен в браузере, функционал сайта ограничен.</small>
            </noscript>
        </div>
    </div>
</div>
<script type='application/ld+json'>
    {
        "@context": "http://www.schema.org",
        "@type": "person",
        "name": "initkfs",
        "jobTitle": "",
        "url": "/index.html"
    }
</script>
            </div>
        </div>
    </div>
</footer>
<div class='mobile-up-wrapper text-center'>
    <button class='btn d-lg-none' id='mobile-page-up-trigger' type='button'><span
            class='mdi mdi-arrow-up'></span> Вверх
    </button>
</div>
<script src="https://code.jquery.com/jquery-3.7.1.min.js" 
integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

<script crossorigin='anonymous' integrity='sha512-TPh2Oxlg1zp+kz3nFA0C5vVC6leG/6mm1z9+mA81MI5eaUVqasPLO8Cuk4gMF4gUfP5etR73rgU/8PNMsSesoQ=='
        src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js'></script>

<script crossorigin='anonymous' integrity='sha512-WW8/jxkELe2CAiE4LvQfwm1rajOS8PHasCCx+knHG0gBHt8EXxS6T6tJRTGuDQVnluuAvMxWF4j8SNFDKceLFg=='
        src='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.2/js/bootstrap.min.js'></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/timeago.js/4.0.2/timeago.full.min.js" integrity="sha512-wb3lqal2VtYhmlPAr232VP+Zus676CFAEYdywxIUSxG6F/X9WhN6SpREkWUdwBvMpd6gCKuKTGHhdum6m1wOvQ==" crossorigin="anonymous"></script>

<script crossorigin='anonymous' integrity='sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q=='
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>

<script crossorigin='anonymous' integrity='sha512-SkmBfuA2hqjzEVpmnMt/LINrjop3GKWqsuLSSB3e7iBmYK7JuWw4ldmmxwD9mdm2IRTTi0OxSAfEGvgEi0i2Kw=='
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" ></script>

<script>
var problemScripts = [];
if (typeof jQuery === 'undefined') {
    problemScripts.push("jquery");
}

   if (typeof Prism === 'undefined'){
    problemScripts.push("prism.js");
   }
   
if (typeof Popper === 'undefined') {
    problemScripts.push("popper.js");
}

if (typeof timeago === 'undefined') {
    problemScripts.push("timeago.js");
}

if (typeof window.bootstrap === 'undefined') {
    problemScripts.push("bootstrap.js");
}

if (problemScripts.length > 0) {
    var message = "Ошибка загрузки JavaScript: " +
        problemScripts.join(",") +
        "." +
        " Возможные причины: блокировщик рекламы, проблемы с сетью, устаревший браузер. Может не работать дополнительный функционал.";

    var failInfoBlock = document.createElement("small");
    failInfoBlock.innerHTML = message;

    var mainFailBlock = document.getElementById("js-fail-block");
    if (!mainFailBlock) {
        console.error(message);
    } else {
        mainFailBlock.appendChild(failInfoBlock);
    }   
}
</script>
<script src="/assets/dev/js/main.js"></script>
</body>
</html>



